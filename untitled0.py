# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F7rBooc1xhfaLqnciRswOPjT3MCHQuOS
"""

import numpy as np
import pandas as pd

"""CORRELATION USED FOR RECOMMENDING NEXT MOVIE!"""

column_names=['user_id','item_id','rating','timestamp']
df=pd.read_csv('u.data',sep='\t',names=column_names)

df.head()

movie_titles=pd.read_csv("Movie_Id_Titles")
movie_titles.head()

df=pd.merge(df,movie_titles,on='item_id')  #merging given dataset with the movie id and title dataset, by arranging them according to the item id of the movie (item_id is the key on which both the tables are combined)
df.head()



"""

---

---

EXPLORATORY DATA ANALYSIS:-

matplotlib and seaborn most imp libraries for EDA used for visualization

"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('white')     #background - white
# %matplotlib inline   
#visualized graphs will be seen within this jupyter notebook by using inline

"""Creating a rating database with avg rating and number of ratings"""

df.groupby('title')['rating'].mean().sort_values(ascending=False).head()     
     #database with rating of movie from most(5.0) to least(0.0)  #the movies with rating 5 is rare event, it might be because the no. of ratings is too less
     #df.groupby('title')['rating'] groups the title of every movie along with their ratings (multiple ratings of a single movie title might occur)
     # .mean() calculates the mean of all the ratings linked to a single movie title
     # sort_values(ascending=False) sorts all ratings in descending order. If this fn was not given, the ratings of movies would get displayed in the same order as that present in the df dataframe

"""Checking the count of the ratings assigned to each movie:-    (displaying them in sorted order - high to low)"""

df.groupby('title')['rating'].count().sort_values(ascending=False).head()

"""Putting the mean values of rating for all the movies mapped with their titles, in another dataframe"""

ratings=pd.DataFrame(df.groupby('title')['rating'].mean())           #pd.DataFrame creates a new dataframe (table) with the necessary data

ratings.head()

"""Adding the 'number of ratings' column to the ratings dataframe"""

ratings['num of ratings']=pd.DataFrame(df.groupby('title')['rating'].count())
ratings.head()

"""Plotting histograms w.r.t the number of ratings of each movie"""

plt.figure(figsize=(10,4))
ratings['num of ratings'].hist(bins=70)

"""Creating a histogram w,r,t ratings"""

plt.figure(figsize=(10,4))
ratings['rating'].hist(bins=70)             

#most of the people seem to have given ratings between 3-4

"""The graph above follows a normal Gaussian distribution, i.e the upper boubdary of graph is a curve, whose PDF (probability density fn.) when found, follows a normal gaussian distribution. 

There are a few **outlines **though, like at 1.0, 3.0 there are spikes in no. of ratings.
"""



"""
Creating a **Joint Plot - helps to plot the graph for a combination of inputs.** On the top of joint graph, it also shows the corresponding histogram
"""

sns.jointplot(x='rating',y='num of ratings',data=ratings,alpha=0.5)

#wherever the plotted points are the most dense, that denotes the number of ratings for movies that are common. For example, a large number of movies have number of ratings=0, so the p[lot is dense at 0]

"""We're done with EDA!

## **Recommending Similar Movies**

Creating a matrix (Pivot table) that has the user ids as the index no. and the movie title as the column names. Each cell in the matrix will consist of the rating the user gave to that movie.

**NOTE**: There will be a ***lot of NaN (null) values*** in the matrix, as most people haven't seen most of the movies
"""

moviemat=df.pivot_table(index='user_id',columns='title',values='rating')
moviemat.head()

# Reason to create the pivot table - suppose ive watched star wars, what is the next movie to recommend me based on the user id and the ratings of movies given by that user

"""Most rated movie: Sorting number of ratings in descending order


"""

ratings.sort_values('num of ratings',ascending=False).head(10)

"""Now, suppose you've watched a movie "Star Wars 1977". Now we'll find the **CORRELATION of this movie with the pivot table** that we had created earlier. And eventually we'll predict which will be the best movie for us to watch next.

Let's consider we've watched Star Wars and Liar Liar. Now, we'll grab the user ratings for these both movies.
"""

starwars_user_ratings=moviemat['Star Wars (1977)']     #extracting information about the movie Star Wars from the PIVOT TABLE
liarliar_user_ratings=moviemat['Liar Liar (1997)']
starwars_user_ratings.head()

#mapping the ratings of star wars given by various user ids

"""With respect to this data attained above, we CORRELATE with the PIVOT TABLE.
Then we'll find the correlation with respect to the user_id.

We use the **corrwidth()** to get correlation between 2 pandas series
"""

similar_to_starwars=moviemat.corrwith(starwars_user_ratings)  #correlating pivot table with the ratings similar to that of Star Wars movie
similar_to_liarliar=moviemat.corrwith(liarliar_user_ratings)

corr_starwars=pd.DataFrame(similar_to_starwars,columns=['Correlation'])
corr_starwars.dropna(inplace=True) #removing NaN values
corr_starwars.head()

"""Now, suppose I have watched a Star Wars movie, the movie with **highest correlation** with the ratings of Star Wars will be the **next recommended movie** for me to watch. Higher the correlation, more likely am I to watch that movie.

**MAXIMUM correlation value = 1**

Considering only the movies for recommendation, whose number of reviews are more than 100.

If we sort the dataframe by correlation, we should get the most similar movies, however all the results don't make sense. This is because there are a ***lot of movies only watched once by users who also watched Star Wars***(star wars being the most popilar movie).
"""

corr_starwars.sort_values('Correlation',ascending=False).head(10)   #Sorting all the correlated movie with starwars on the basis of their values of correlation, in descending order

"""There are some movies with correlation 1.0 (or 100%) which is ***rarely possible practically*** (unless a movie is correlated with itself). To fix this, we ***filter out movies that have less than 100 reviews*** (this filtering value can be customised according to the histogram shown above)"""

corr_starwars=corr_starwars.join(ratings['num of ratings'])
corr_starwars.head(10)

"""Sorting the movies in correlation with star wars, based upon the correlation with star wars, in descending order"""

corr_starwars[corr_starwars['num of ratings']>100].sort_values('Correlation',ascending=False).head()  #will only consider movies whose 'num of ratings'>100

"""

**Doing the same CORRELATION method for Liar Liar movie:-**
"""

corr_liarliar=pd.DataFrame(similar_to_liarliar,columns=['Correlation'])
corr_liarliar.dropna(inplace=True)
corr_liarliar=corr_liarliar.join(ratings['num of ratings'])
corr_liarliar[corr_liarliar['num of ratings']>100].sort_values('Correlation',ascending=False).head()

